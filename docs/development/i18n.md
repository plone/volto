---
myst:
  html_meta:
    "description": "Rules and guidelines for internationalization (i18n) in Seven."
    "property=og:description": "Rules and guidelines for internationalization (i18n) in Seven."
    "property=og:title": "internationalization (i18n)"
    "keywords": "Seven, Plone, frontend, React, configuration, i18n"
---

# Internationalization (i18n)

Seven uses [react-i18next](https://react.i18next.com/) for {term}`internationalization` (i18n), providing a modern approach to managing translations in React applications.
This guide covers how to add translations to your code and organize translation files in your add-ons.

## Prerequisites

To use translations in your add-on, you'll need to set up your environment with the following prerequisites.

Install `react-i18next` as a dependency in your add-on with the following command, substituting the name of your add-on.

```shell
pnpm --filter <my-add-on> add react-i18next
```

Then, in your add-on's {file}`package.json`, change the dependency to use the catalog as shown.

```{code-block} json
:caption: {file}`package.json`
{
  "dependencies": {
    "react-i18next": "catalog:"
  }
}
```

Using `catalog:` ensures that your add-on uses the same version of `react-i18next` as the Seven core.

After modifying {file}`package.json`, apply the changes with the following command.

```shell
pnpm install
```

## Translations in React components

To add translations to your React components, use the `useTranslation` hook from `react-i18next`.

```tsx
import { useTranslation } from 'react-i18next';

export default function MyComponent() {
  const { t } = useTranslation();

  return (
    <div>
      <h1>{t('my-add-on.welcome')}</h1>
      <p>{t('my-add-on.description')}</p>
    </div>
  );
}
```

The `t` function translates the given key into the current language.
You can also use interpolation for dynamic values.
First, in your add-on code, use the following pattern.

```tsx
const { t } = useTranslation();
const username = 'John';

return <p>{t('my-add-on.greeting', { username })}</p>;
```

Then in your translation file, add the translation key and value for your add-on.

```json
{
  "my-add-on": {
    "greeting": "Hello, {{username}}!"
  }
}
```

## Folder structure for translations

Translation files must be organized in a {file}`locales` folder at the root of your add-on in the following structure.

```text
my-add-on/
├── locales/
│   ├── en/
│   │   └── common.json
│   ├── it/
│   │   └── common.json
│   └── de/
│       └── common.json
├── index.ts
└── package.json
```

Each language has its own folder—for example, `en` for English, `it` for Italian, or `de` for German—according to the i18next documentation [_How should the language codes be formatted?_](https://www.i18next.com/how-to/faq#how-should-the-language-codes-be-formatted).

Next, inside each language folder, you must create a {file}`common.json` file.

## The `common` namespace

Currently, Seven only supports the `common` namespace.
This means all translation files **must** be named `common.json`.

```{note}
Support for additional namespaces may be added in future versions.
```

## Organizing translations to avoid collisions

To avoid translation key collisions between different add-ons, it is **strongly recommended** to nest your translations under a key that matches your add-on name.

For example, if your add-on is named `my-addon`, structure your translations like this:

```json
{
  "myaddon": {
    "welcome": "Welcome to My Add-on",
    "description": "This is a description",
    "button": {
      "save": "Save",
      "cancel": "Cancel"
    }
  }
}
```

Then in your code, reference translations with the add-on prefix:

```tsx
t('myaddon.welcome');
t('myaddon.button.save');
```

This prevents conflicts if another add-on uses the same key names.

## Example translation file

Here's a complete example of a `locales/en/common.json` file from the `@plone/cmsui` package:

```json
{
  "cmsui": {
    "edit": "Edit",
    "save": "Save",
    "controlpanel": "Control Panel",
    "objectbrowserwidget": {
      "openDialog": "Select content",
      "dialogTitle": "Select Content",
      "closeDialog": "Close selection",
      "loading": "Loading...",
      "noResults": "No content found"
    }
  }
}
```

And the corresponding usage in code:

```tsx
import { useTranslation } from 'react-i18next';

export default function EditButton() {
  const { t } = useTranslation();

  return <button>{t('cmsui.save')}</button>;
}
```

## Server restart required for translation changes

```{important}
When you modify translation files, you **must restart the development server** for changes to take effect.
```

Translation files are merged and processed by the registry at server startup.
The registry collects translations from all registered add-ons and generates the final translation files.

This process happens only once during server initialization, so any changes to translation files require a server restart to be reflected in the application.

## How the registry handles translations

When the server starts:

1. The registry discovers all add-ons configured in your application
2. It collects translation files from each add-on's `locales` folder
3. Translation files are merged following the add-on order in the registry

This automatic merging means:

- Add-ons can provide their own translations
- Later add-ons in the registry can override translations from earlier ones
