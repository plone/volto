{"version":3,"sources":["webpack:///./node_modules/react-window/node_modules/memoize-one/dist/memoize-one.esm.js","webpack:///./node_modules/react-window/dist/index.esm.js"],"names":["safeIsNaN","Number","isNaN","value","areInputsEqual","newInputs","lastInputs","length","i","first","second","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","this","apply","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","size","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","defaultItemKey","_ref","columnIndex","data","rowIndex","createGridComponent","_ref2","_class","_temp","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","_offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","defaultProps","_ref5","_ref6","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","defaultItemKey$1","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","List","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_event$currentTarget2","validateSharedProps$1","_this$_getRangeToRend","_getRangeToRender","_index","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_scrollDirection","_scrollOffset","getItemMetadata$1","findNearestItemBinarySearch$1","findNearestItemExponentialSearch$1","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","findNearestItem$1","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","_ref8","lastRowOffset","_ref9","_ref10","numVisibleColumns","_ref11","_ref12","numVisibleRows","_ref13","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","_attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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","file":"static/js/40.90de6e4a.chunk.js","sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsOverscanRowsColumnsCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}