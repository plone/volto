export namespace loadables {
    let prettierStandalone: import("@loadable/component").LoadableLibrary<{
        default: typeof import("prettier/standalone");
        formatWithCursor(source: string, options: import("prettier").CursorOptions): Promise<import("prettier").CursorResult>;
        format(source: string, options?: import("prettier").Options): Promise<string>;
        check(source: string, options?: import("prettier").Options): Promise<boolean>;
        getSupportInfo(): Promise<import("prettier").SupportInfo>;
    }>;
    let prettierParserHtml: import("@loadable/component").LoadableLibrary<{
        default: typeof import("prettier/plugins/html");
        parsers: {
            angular: import("prettier").Parser<any>;
            html: import("prettier").Parser<any>;
            lwc: import("prettier").Parser<any>;
            vue: import("prettier").Parser<any>;
        };
    }>;
    let prismCore: any;
    let toastify: import("@loadable/component").LoadableLibrary<{
        default: typeof import("react-toastify");
        cssTransition(props: import("react-toastify").cssTransitionProps): import("react").ComponentType<{}>;
        ToastType: import("react-toastify").Type;
        ToastPosition: import("react-toastify").Position;
        ToastContainer: typeof import("react-toastify").ToastContainer;
        toast: import("react-toastify").Toast;
        Slide: import("react").ComponentType<{}>;
        Bounce: import("react").ComponentType<{}>;
        Flip: import("react").ComponentType<{}>;
        Zoom: import("react").ComponentType<{}>;
    }>;
    let reactSelect: any;
    let reactVirtualized: any;
    let reactSortableHOC: import("@loadable/component").LoadableLibrary<{
        default: typeof import("react-sortable-hoc");
        SortableContainer<P>(wrappedComponent: any, config?: import("react-sortable-hoc").Config): import("react").ComponentClass<P & import("react-sortable-hoc").SortableContainerProps, any>;
        SortableElement<P_1>(wrappedComponent: any, config?: import("react-sortable-hoc").Config): import("react").ComponentClass<P_1 & import("react-sortable-hoc").SortableElementProps, any>;
        SortableHandle<P_2>(wrappedComponent: any, config?: import("react-sortable-hoc").Config): import("react").ComponentClass<P_2, any>;
        arrayMove<T>(collection: T[], previousIndex: number, newIndex: number): T[];
    }>;
    let reactSelectAsyncPaginate: import("@loadable/component").LoadableLibrary<{
        default: typeof import("react-select-async-paginate");
        wrapMenuList: (MenuList: import("react").ComponentType<{
            innerRef: import("react").Ref<HTMLElement>;
        }>) => import("react").FC<import("react-select-async-paginate/ts/wrapMenuList").Props>;
        reduceGroupedOptions: import("react-select-async-paginate").ReduceOptions<any, any>;
        withAsyncPaginate: typeof import("react-select-async-paginate").withAsyncPaginate;
        useAsyncPaginateBase: <OptionType, Additional>(params: import("react-select-async-paginate").UseAsyncPaginateBaseParams<OptionType, Additional>, deps?: readonly any[]) => import("react-select-async-paginate").UseAsyncPaginateBaseResult<OptionType>;
        useAsyncPaginate: <OptionType_1, Additional_1>(params: import("react-select-async-paginate").UseAsyncPaginateParams<OptionType_1, Additional_1>, deps?: readonly any[]) => import("react-select-async-paginate").UseAsyncPaginateResult<OptionType_1>;
        useComponents: <OptionType_2, IsMulti extends boolean>(components: any) => any;
        AsyncPaginate: import("react").FC<any>;
    }>;
    let reactSelectAsync: any;
    let reactSelectCreateable: any;
    let reactSelectAsyncCreateable: any;
    let diffLib: any;
    let moment: import("@loadable/component").LoadableLibrary<{
        default: typeof import("moment");
        utc(inp?: import("moment").MomentInput, strict?: boolean): import("moment").Moment;
        utc(inp?: import("moment").MomentInput, format?: import("moment").MomentFormatSpecification, strict?: boolean): import("moment").Moment;
        utc(inp?: import("moment").MomentInput, format?: import("moment").MomentFormatSpecification, language?: string, strict?: boolean): import("moment").Moment;
        unix(timestamp: number): import("moment").Moment;
        invalid(flags?: import("moment").MomentParsingFlagsOpt): import("moment").Moment;
        isMoment(m: any): m is import("moment").Moment;
        isDate(m: any): m is Date;
        isDuration(d: any): d is import("moment").Duration;
        lang(language?: string): string;
        lang(language?: string, definition?: import("moment").Locale): string;
        locale(language?: string): string;
        locale(language?: string[]): string;
        locale(language?: string, definition?: import("moment").LocaleSpecification): string;
        localeData(key?: string | string[]): import("moment").Locale;
        duration(inp?: import("moment").DurationInputArg1, unit?: import("moment").unitOfTime.DurationConstructor): import("moment").Duration;
        parseZone(inp?: import("moment").MomentInput, format?: import("moment").MomentFormatSpecification, strict?: boolean): import("moment").Moment;
        parseZone(inp?: import("moment").MomentInput, format?: import("moment").MomentFormatSpecification, language?: string, strict?: boolean): import("moment").Moment;
        months(): string[];
        months(index: number): string;
        months(format: string): string[];
        months(format: string, index: number): string;
        monthsShort(): string[];
        monthsShort(index: number): string;
        monthsShort(format: string): string[];
        monthsShort(format: string, index: number): string;
        weekdays(): string[];
        weekdays(index: number): string;
        weekdays(format: string): string[];
        weekdays(format: string, index: number): string;
        weekdays(localeSorted: boolean): string[];
        weekdays(localeSorted: boolean, index: number): string;
        weekdays(localeSorted: boolean, format: string): string[];
        weekdays(localeSorted: boolean, format: string, index: number): string;
        weekdaysShort(): string[];
        weekdaysShort(index: number): string;
        weekdaysShort(format: string): string[];
        weekdaysShort(format: string, index: number): string;
        weekdaysShort(localeSorted: boolean): string[];
        weekdaysShort(localeSorted: boolean, index: number): string;
        weekdaysShort(localeSorted: boolean, format: string): string[];
        weekdaysShort(localeSorted: boolean, format: string, index: number): string;
        weekdaysMin(): string[];
        weekdaysMin(index: number): string;
        weekdaysMin(format: string): string[];
        weekdaysMin(format: string, index: number): string;
        weekdaysMin(localeSorted: boolean): string[];
        weekdaysMin(localeSorted: boolean, index: number): string;
        weekdaysMin(localeSorted: boolean, format: string): string[];
        weekdaysMin(localeSorted: boolean, format: string, index: number): string;
        min(moments: import("moment").Moment[]): import("moment").Moment;
        min(...moments: import("moment").Moment[]): import("moment").Moment;
        max(moments: import("moment").Moment[]): import("moment").Moment;
        max(...moments: import("moment").Moment[]): import("moment").Moment;
        now(): number;
        defineLocale(language: string, localeSpec: import("moment").LocaleSpecification): import("moment").Locale;
        updateLocale(language: string, localeSpec: import("moment").LocaleSpecification): import("moment").Locale;
        locales(): string[];
        normalizeUnits(unit: import("moment").unitOfTime.All): string;
        relativeTimeThreshold(threshold: string): number | boolean;
        relativeTimeThreshold(threshold: string, limit: number): boolean;
        relativeTimeRounding(fn: (num: number) => number): boolean;
        relativeTimeRounding(): (num: number) => number;
        calendarFormat(m: import("moment").Moment, now: import("moment").Moment): string;
        parseTwoDigitYear(input: string): number;
        version: string;
        fn: import("moment").Moment;
        ISO_8601: import("moment").MomentBuiltinFormat;
        RFC_2822: import("moment").MomentBuiltinFormat;
        defaultFormat: string;
        defaultFormatUtc: string;
        suppressDeprecationWarnings: boolean;
        deprecationHandler: (name: string, msg: string) => void;
        HTML5_FMT: {
            DATETIME_LOCAL: string;
            DATETIME_LOCAL_SECONDS: string;
            DATETIME_LOCAL_MS: string;
            DATE: string;
            TIME: string;
            TIME_SECONDS: string;
            TIME_MS: string;
            WEEK: string;
            MONTH: string;
        };
    }>;
    let reactDates: any;
    let reactDnd: import("@loadable/component").LoadableLibrary<{
        default: typeof import("react-dnd");
        DragDropContext: typeof import("react-dnd").DragDropContext;
        DragDropContextProvider: React.SFC<import("react-dnd").DragDropContextProviderProps<any>>;
        DragLayer: typeof import("react-dnd").DragLayer;
        DragSource: typeof import("react-dnd").DragSource;
        DropTarget: typeof import("react-dnd").DropTarget;
        XYCoord: any;
    }>;
    let reactDndHtml5Backend: import("@loadable/component").LoadableLibrary<typeof import("react-dnd-html5-backend")>;
    let reactBeautifulDnd: any;
    let rrule: import("@loadable/component").LoadableLibrary<{
        default: typeof import("rrule");
        RRule: typeof import("rrule").RRule;
        RRuleSet: typeof import("rrule").RRuleSet;
        rrulestr: typeof import("rrule").rrulestr;
        Frequency: typeof import("rrule").Frequency;
        Weekday: typeof import("rrule").Weekday;
    }>;
}
