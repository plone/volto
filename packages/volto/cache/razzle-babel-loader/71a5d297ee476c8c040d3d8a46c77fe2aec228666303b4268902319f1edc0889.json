{"ast":null,"code":"import config from '@plone/volto/registry';\n\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetByFieldId\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFieldId = id => config.widgets.views.id[id] || null;\n\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByName = widget => typeof widget === 'string' ? config.widgets.views.widget[widget] : null;\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabulary = vocabulary => vocabulary && vocabulary['@id'] ? config.widgets.views.vocabulary[vocabulary['@id'].replace(`${config.settings.apiPath}/@vocabularies/`, '')] : null;\n\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabularyFromHint = props => props.widgetOptions && props.widgetOptions.vocabulary ? config.widgets.views.vocabulary[props.widgetOptions.vocabulary['@id'].replace(`${config.settings.apiPath}/@vocabularies/`, '')] : null;\n\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByChoices = props => {\n  if (props.choices) {\n    return config.widgets.views.choices;\n  }\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.views.choices;\n  }\n  return null;\n};\n\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\nconst getWidgetByType = type => config.widgets.views.type[type] || null;\n\n/**\n * Get default widget\n * @method getWidgetDefault\n * @returns {string} Widget component.\n */\nconst getWidgetDefault = () => config.widgets.views.default;\n\n/**\n * Get Widget View\n * @method getWidgetView\n * @param {dict} props Props\n * @returns {string} Widget component.\n */\nexport const getWidgetView = props => getWidgetByFieldId(props.id) || getWidgetByName(props.widget) || getWidgetByChoices(props) || getWidgetByVocabulary(props.vocabulary) || getWidgetByVocabularyFromHint(props) || getWidgetByType(props.type) || getWidgetDefault();","map":{"version":3,"names":["config","getWidgetByFieldId","id","widgets","views","getWidgetByName","widget","getWidgetByVocabulary","vocabulary","replace","settings","apiPath","getWidgetByVocabularyFromHint","props","widgetOptions","getWidgetByChoices","choices","getWidgetByType","type","getWidgetDefault","default","getWidgetView"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/Widget/widget.js"],"sourcesContent":["import config from '@plone/volto/registry';\n\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetByFieldId\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFieldId = (id) => config.widgets.views.id[id] || null;\n\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByName = (widget) =>\n  typeof widget === 'string' ? config.widgets.views.widget[widget] : null;\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabulary = (vocabulary) =>\n  vocabulary && vocabulary['@id']\n    ? config.widgets.views.vocabulary[\n        vocabulary['@id'].replace(\n          `${config.settings.apiPath}/@vocabularies/`,\n          '',\n        )\n      ]\n    : null;\n\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabularyFromHint = (props) =>\n  props.widgetOptions && props.widgetOptions.vocabulary\n    ? config.widgets.views.vocabulary[\n        props.widgetOptions.vocabulary['@id'].replace(\n          `${config.settings.apiPath}/@vocabularies/`,\n          '',\n        )\n      ]\n    : null;\n\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByChoices = (props) => {\n  if (props.choices) {\n    return config.widgets.views.choices;\n  }\n\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.views.choices;\n  }\n\n  return null;\n};\n\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\nconst getWidgetByType = (type) => config.widgets.views.type[type] || null;\n\n/**\n * Get default widget\n * @method getWidgetDefault\n * @returns {string} Widget component.\n */\nconst getWidgetDefault = () => config.widgets.views.default;\n\n/**\n * Get Widget View\n * @method getWidgetView\n * @param {dict} props Props\n * @returns {string} Widget component.\n */\nexport const getWidgetView = (props) =>\n  getWidgetByFieldId(props.id) ||\n  getWidgetByName(props.widget) ||\n  getWidgetByChoices(props) ||\n  getWidgetByVocabulary(props.vocabulary) ||\n  getWidgetByVocabularyFromHint(props) ||\n  getWidgetByType(props.type) ||\n  getWidgetDefault();\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAIC,EAAE,IAAKF,MAAM,CAACG,OAAO,CAACC,KAAK,CAACF,EAAE,CAACA,EAAE,CAAC,IAAI,IAAI;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,eAAe,GAAIC,MAAM,IAC7B,OAAOA,MAAM,KAAK,QAAQ,GAAGN,MAAM,CAACG,OAAO,CAACC,KAAK,CAACE,MAAM,CAACA,MAAM,CAAC,GAAG,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAIC,UAAU,IACvCA,UAAU,IAAIA,UAAU,CAAC,KAAK,CAAC,GAC3BR,MAAM,CAACG,OAAO,CAACC,KAAK,CAACI,UAAU,CAC7BA,UAAU,CAAC,KAAK,CAAC,CAACC,OAAO,CACvB,GAAGT,MAAM,CAACU,QAAQ,CAACC,OAAO,iBAAiB,EAC3C,EACF,CAAC,CACF,GACD,IAAI;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,6BAA6B,GAAIC,KAAK,IAC1CA,KAAK,CAACC,aAAa,IAAID,KAAK,CAACC,aAAa,CAACN,UAAU,GACjDR,MAAM,CAACG,OAAO,CAACC,KAAK,CAACI,UAAU,CAC7BK,KAAK,CAACC,aAAa,CAACN,UAAU,CAAC,KAAK,CAAC,CAACC,OAAO,CAC3C,GAAGT,MAAM,CAACU,QAAQ,CAACC,OAAO,iBAAiB,EAC3C,EACF,CAAC,CACF,GACD,IAAI;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,kBAAkB,GAAIF,KAAK,IAAK;EACpC,IAAIA,KAAK,CAACG,OAAO,EAAE;IACjB,OAAOhB,MAAM,CAACG,OAAO,CAACC,KAAK,CAACY,OAAO;EACrC;EAEA,IAAIH,KAAK,CAACL,UAAU,EAAE;IACpB;IACA;IACA;IACA,OAAOR,MAAM,CAACG,OAAO,CAACC,KAAK,CAACY,OAAO;EACrC;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAIC,IAAI,IAAKlB,MAAM,CAACG,OAAO,CAACC,KAAK,CAACc,IAAI,CAACA,IAAI,CAAC,IAAI,IAAI;;AAEzE;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAGA,CAAA,KAAMnB,MAAM,CAACG,OAAO,CAACC,KAAK,CAACgB,OAAO;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAIR,KAAK,IACjCZ,kBAAkB,CAACY,KAAK,CAACX,EAAE,CAAC,IAC5BG,eAAe,CAACQ,KAAK,CAACP,MAAM,CAAC,IAC7BS,kBAAkB,CAACF,KAAK,CAAC,IACzBN,qBAAqB,CAACM,KAAK,CAACL,UAAU,CAAC,IACvCI,6BAA6B,CAACC,KAAK,CAAC,IACpCI,eAAe,CAACJ,KAAK,CAACK,IAAI,CAAC,IAC3BC,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}