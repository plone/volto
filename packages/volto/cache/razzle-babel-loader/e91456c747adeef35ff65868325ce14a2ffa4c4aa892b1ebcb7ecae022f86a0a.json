{"ast":null,"code":"import { Text, Transforms, Element, Node } from 'slate'; // Editor,\nimport config from '@plone/volto/registry';\nexport const normalizeNode = editor => {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  const {\n    normalizeNode\n  } = editor;\n  const {\n    slate\n  } = config.settings;\n  const validListElements = [...slate.listTypes, slate.listItemType];\n  editor.normalizeNode = entry => {\n    const [node, path] = entry;\n    const isTextNode = Text.isText(node);\n    const isInlineNode = editor.isInline(node);\n    const isElementNode = Element.isElement(node);\n    const isListTypeNode = slate.listTypes.includes(node.type);\n\n    // delete childless ul/ol nodes\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (!validListElements.includes(child.type) && !validListElements.includes(node.type)) {\n          Transforms.liftNodes(editor, {\n            at: childPath,\n            split: true\n          });\n\n          // Alternate strategy, need to investigate\n          // const newParent = { type: slate.defaultBlockType, children: [] };\n          // Transforms.wrapNodes(editor, newParent, { at: childPath });\n          return;\n        }\n      }\n    }\n    normalizeNode(entry);\n  };\n  return editor;\n};","map":{"version":3,"names":["Text","Transforms","Element","Node","config","normalizeNode","editor","slate","settings","validListElements","listTypes","listItemType","entry","node","path","isTextNode","isText","isInlineNode","isInline","isElementNode","isElement","isListTypeNode","includes","type","children","length","removeNodes","at","child","childPath","liftNodes","split"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/extensions/normalizeNode.js"],"sourcesContent":["import { Text, Transforms, Element, Node } from 'slate'; // Editor,\nimport config from '@plone/volto/registry';\n\nexport const normalizeNode = (editor) => {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  const { normalizeNode } = editor;\n  const { slate } = config.settings;\n\n  const validListElements = [...slate.listTypes, slate.listItemType];\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    const isTextNode = Text.isText(node);\n    const isInlineNode = editor.isInline(node);\n    const isElementNode = Element.isElement(node);\n    const isListTypeNode = slate.listTypes.includes(node.type);\n\n    // delete childless ul/ol nodes\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, { at: path });\n        return;\n      }\n    }\n\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (\n          !validListElements.includes(child.type) &&\n          !validListElements.includes(node.type)\n        ) {\n          Transforms.liftNodes(editor, { at: childPath, split: true });\n\n          // Alternate strategy, need to investigate\n          // const newParent = { type: slate.defaultBlockType, children: [] };\n          // Transforms.wrapNodes(editor, newParent, { at: childPath });\n          return;\n        }\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,UAAU,EAAEC,OAAO,EAAEC,IAAI,QAAQ,OAAO,CAAC,CAAC;AACzD,OAAOC,MAAM,MAAM,uBAAuB;AAE1C,OAAO,MAAMC,aAAa,GAAIC,MAAM,IAAK;EACvC;EACA,MAAM;IAAED;EAAc,CAAC,GAAGC,MAAM;EAChC,MAAM;IAAEC;EAAM,CAAC,GAAGH,MAAM,CAACI,QAAQ;EAEjC,MAAMC,iBAAiB,GAAG,CAAC,GAAGF,KAAK,CAACG,SAAS,EAAEH,KAAK,CAACI,YAAY,CAAC;EAElEL,MAAM,CAACD,aAAa,GAAIO,KAAK,IAAK;IAChC,MAAM,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAGF,KAAK;IAE1B,MAAMG,UAAU,GAAGf,IAAI,CAACgB,MAAM,CAACH,IAAI,CAAC;IACpC,MAAMI,YAAY,GAAGX,MAAM,CAACY,QAAQ,CAACL,IAAI,CAAC;IAC1C,MAAMM,aAAa,GAAGjB,OAAO,CAACkB,SAAS,CAACP,IAAI,CAAC;IAC7C,MAAMQ,cAAc,GAAGd,KAAK,CAACG,SAAS,CAACY,QAAQ,CAACT,IAAI,CAACU,IAAI,CAAC;;IAE1D;IACA,IAAI,CAACR,UAAU,IAAII,aAAa,IAAI,CAACF,YAAY,IAAII,cAAc,EAAE;MACnE,IAAI,CAACR,IAAI,CAACW,QAAQ,IAAI,EAAE,EAAEC,MAAM,KAAK,CAAC,EAAE;QACtCxB,UAAU,CAACyB,WAAW,CAACpB,MAAM,EAAE;UAAEqB,EAAE,EAAEb;QAAK,CAAC,CAAC;QAC5C;MACF;IACF;IAEA,IAAIK,aAAa,IAAIE,cAAc,EAAE;MACnC;MACA,KAAK,MAAM,CAACO,KAAK,EAAEC,SAAS,CAAC,IAAI1B,IAAI,CAACqB,QAAQ,CAAClB,MAAM,EAAEQ,IAAI,CAAC,EAAE;QAC5D,IACE,CAACL,iBAAiB,CAACa,QAAQ,CAACM,KAAK,CAACL,IAAI,CAAC,IACvC,CAACd,iBAAiB,CAACa,QAAQ,CAACT,IAAI,CAACU,IAAI,CAAC,EACtC;UACAtB,UAAU,CAAC6B,SAAS,CAACxB,MAAM,EAAE;YAAEqB,EAAE,EAAEE,SAAS;YAAEE,KAAK,EAAE;UAAK,CAAC,CAAC;;UAE5D;UACA;UACA;UACA;QACF;MACF;IACF;IAEA1B,aAAa,CAACO,KAAK,CAAC;EACtB,CAAC;EAED,OAAON,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}