{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { Editor, Transforms } from 'slate';\nimport { TABLE, THEAD, TBODY, TFOOT, TD, TH, TR } from '@plone/volto-slate/constants';\n\n/**\n * @param {Array} rows The array of rows that almost completely defines a\n * `table`-typed block.\n * @returns {Array} A tuple `[id, block]` where `id` is the new block's ID and\n * the `block` is all the block's data.\n */\nexport function syncCreateTableBlock(rows) {\n  const id = uuid();\n  const block = {\n    '@type': 'table',\n    table: {\n      rows\n    }\n  };\n  return [id, block];\n}\n\n/**\n * @param {Editor} editor The Slate Editor from which to extract tables.\n * @param {PathRef} pathRef Has the current value a `Path` so that the search is\n * done just inside nodes in that `Path`.\n * @returns Extracts tables from a Slate `Editor` into an array of detached\n * `table` blocks.\n */\nexport const extractTables = (editor, pathRef) => {\n  const tableNodes = Array.from(Editor.nodes(editor, {\n    at: pathRef.current,\n    match: node => node.type === TABLE\n  }));\n  const tables = tableNodes.map(([node]) => extractVoltoTable(node));\n  Transforms.removeNodes(editor, {\n    at: pathRef.current,\n    match: node => node.type === TABLE\n  });\n  return tables.map(el => syncCreateTableBlock(el));\n};\n\n/**\n * @param {Node[]} fragment A Slate document fragment.\n * @returns {Array} An array of rows in the format requested by `table`\n * blocks.\n */\nfunction collectRowsFrom(fragment) {\n  let rows = [];\n  fragment.children.forEach(y => {\n    if (y.type === TR) {\n      let row = {\n        key: uuid(),\n        cells: []\n      };\n      y.children.forEach(z => {\n        let val = JSON.parse(JSON.stringify(z.children));\n        if (z.type === TD) {\n          row.cells.push({\n            key: uuid(),\n            type: 'data',\n            value: val\n          });\n        } else if (z.type === TH) {\n          row.cells.push({\n            key: uuid(),\n            type: 'header',\n            value: val\n          });\n        }\n      });\n      rows.push(row);\n    }\n  });\n  return rows;\n}\n\n/**\n * @param {HTMLElement} el The <table> element from which to extract rows.\n * @returns {Array} A rows array that contains rows in the format required by\n * `table` blocks.\n */\nfunction extractVoltoTable(el) {\n  let thead = [],\n    tfoot = [],\n    tbody = [];\n  el.children.forEach(fragment => {\n    if (fragment.type === THEAD) {\n      // not supported by View fully, so prepend this to tbody below\n      thead = collectRowsFrom(fragment);\n    } else if (fragment.type === TBODY) {\n      tbody = collectRowsFrom(fragment);\n    } else if (fragment.type === TFOOT) {\n      // not supported by View fully, so append this to tbody below\n      tfoot = collectRowsFrom(fragment);\n    }\n  });\n  const rows = [...thead, ...tbody, ...tfoot];\n  return rows;\n}","map":{"version":3,"names":["v4","uuid","Editor","Transforms","TABLE","THEAD","TBODY","TFOOT","TD","TH","TR","syncCreateTableBlock","rows","id","block","table","extractTables","editor","pathRef","tableNodes","Array","from","nodes","at","current","match","node","type","tables","map","extractVoltoTable","removeNodes","el","collectRowsFrom","fragment","children","forEach","y","row","key","cells","z","val","JSON","parse","stringify","push","value","thead","tfoot","tbody"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/blocks/Table/deconstruct.js"],"sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { Editor, Transforms } from 'slate';\nimport {\n  TABLE,\n  THEAD,\n  TBODY,\n  TFOOT,\n  TD,\n  TH,\n  TR,\n} from '@plone/volto-slate/constants';\n\n/**\n * @param {Array} rows The array of rows that almost completely defines a\n * `table`-typed block.\n * @returns {Array} A tuple `[id, block]` where `id` is the new block's ID and\n * the `block` is all the block's data.\n */\nexport function syncCreateTableBlock(rows) {\n  const id = uuid();\n  const block = {\n    '@type': 'table',\n    table: {\n      rows,\n    },\n  };\n  return [id, block];\n}\n\n/**\n * @param {Editor} editor The Slate Editor from which to extract tables.\n * @param {PathRef} pathRef Has the current value a `Path` so that the search is\n * done just inside nodes in that `Path`.\n * @returns Extracts tables from a Slate `Editor` into an array of detached\n * `table` blocks.\n */\nexport const extractTables = (editor, pathRef) => {\n  const tableNodes = Array.from(\n    Editor.nodes(editor, {\n      at: pathRef.current,\n      match: (node) => node.type === TABLE,\n    }),\n  );\n  const tables = tableNodes.map(([node]) => extractVoltoTable(node));\n\n  Transforms.removeNodes(editor, {\n    at: pathRef.current,\n    match: (node) => node.type === TABLE,\n  });\n\n  return tables.map((el) => syncCreateTableBlock(el));\n};\n\n/**\n * @param {Node[]} fragment A Slate document fragment.\n * @returns {Array} An array of rows in the format requested by `table`\n * blocks.\n */\nfunction collectRowsFrom(fragment) {\n  let rows = [];\n  fragment.children.forEach((y) => {\n    if (y.type === TR) {\n      let row = { key: uuid(), cells: [] };\n\n      y.children.forEach((z) => {\n        let val = JSON.parse(JSON.stringify(z.children));\n        if (z.type === TD) {\n          row.cells.push({\n            key: uuid(),\n            type: 'data',\n            value: val,\n          });\n        } else if (z.type === TH) {\n          row.cells.push({\n            key: uuid(),\n            type: 'header',\n            value: val,\n          });\n        }\n      });\n\n      rows.push(row);\n    }\n  });\n  return rows;\n}\n\n/**\n * @param {HTMLElement} el The <table> element from which to extract rows.\n * @returns {Array} A rows array that contains rows in the format required by\n * `table` blocks.\n */\nfunction extractVoltoTable(el) {\n  let thead = [],\n    tfoot = [],\n    tbody = [];\n\n  el.children.forEach((fragment) => {\n    if (fragment.type === THEAD) {\n      // not supported by View fully, so prepend this to tbody below\n      thead = collectRowsFrom(fragment);\n    } else if (fragment.type === TBODY) {\n      tbody = collectRowsFrom(fragment);\n    } else if (fragment.type === TFOOT) {\n      // not supported by View fully, so append this to tbody below\n      tfoot = collectRowsFrom(fragment);\n    }\n  });\n\n  const rows = [...thead, ...tbody, ...tfoot];\n\n  return rows;\n}\n"],"mappings":"AAAA,SAASA,EAAE,IAAIC,IAAI,QAAQ,MAAM;AACjC,SAASC,MAAM,EAAEC,UAAU,QAAQ,OAAO;AAC1C,SACEC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,EAAE,EACFC,EAAE,EACFC,EAAE,QACG,8BAA8B;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACC,IAAI,EAAE;EACzC,MAAMC,EAAE,GAAGZ,IAAI,CAAC,CAAC;EACjB,MAAMa,KAAK,GAAG;IACZ,OAAO,EAAE,OAAO;IAChBC,KAAK,EAAE;MACLH;IACF;EACF,CAAC;EACD,OAAO,CAACC,EAAE,EAAEC,KAAK,CAAC;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,aAAa,GAAGA,CAACC,MAAM,EAAEC,OAAO,KAAK;EAChD,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAC3BnB,MAAM,CAACoB,KAAK,CAACL,MAAM,EAAE;IACnBM,EAAE,EAAEL,OAAO,CAACM,OAAO;IACnBC,KAAK,EAAGC,IAAI,IAAKA,IAAI,CAACC,IAAI,KAAKvB;EACjC,CAAC,CACH,CAAC;EACD,MAAMwB,MAAM,GAAGT,UAAU,CAACU,GAAG,CAAC,CAAC,CAACH,IAAI,CAAC,KAAKI,iBAAiB,CAACJ,IAAI,CAAC,CAAC;EAElEvB,UAAU,CAAC4B,WAAW,CAACd,MAAM,EAAE;IAC7BM,EAAE,EAAEL,OAAO,CAACM,OAAO;IACnBC,KAAK,EAAGC,IAAI,IAAKA,IAAI,CAACC,IAAI,KAAKvB;EACjC,CAAC,CAAC;EAEF,OAAOwB,MAAM,CAACC,GAAG,CAAEG,EAAE,IAAKrB,oBAAoB,CAACqB,EAAE,CAAC,CAAC;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,QAAQ,EAAE;EACjC,IAAItB,IAAI,GAAG,EAAE;EACbsB,QAAQ,CAACC,QAAQ,CAACC,OAAO,CAAEC,CAAC,IAAK;IAC/B,IAAIA,CAAC,CAACV,IAAI,KAAKjB,EAAE,EAAE;MACjB,IAAI4B,GAAG,GAAG;QAAEC,GAAG,EAAEtC,IAAI,CAAC,CAAC;QAAEuC,KAAK,EAAE;MAAG,CAAC;MAEpCH,CAAC,CAACF,QAAQ,CAACC,OAAO,CAAEK,CAAC,IAAK;QACxB,IAAIC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACJ,CAAC,CAACN,QAAQ,CAAC,CAAC;QAChD,IAAIM,CAAC,CAACd,IAAI,KAAKnB,EAAE,EAAE;UACjB8B,GAAG,CAACE,KAAK,CAACM,IAAI,CAAC;YACbP,GAAG,EAAEtC,IAAI,CAAC,CAAC;YACX0B,IAAI,EAAE,MAAM;YACZoB,KAAK,EAAEL;UACT,CAAC,CAAC;QACJ,CAAC,MAAM,IAAID,CAAC,CAACd,IAAI,KAAKlB,EAAE,EAAE;UACxB6B,GAAG,CAACE,KAAK,CAACM,IAAI,CAAC;YACbP,GAAG,EAAEtC,IAAI,CAAC,CAAC;YACX0B,IAAI,EAAE,QAAQ;YACdoB,KAAK,EAAEL;UACT,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF9B,IAAI,CAACkC,IAAI,CAACR,GAAG,CAAC;IAChB;EACF,CAAC,CAAC;EACF,OAAO1B,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASkB,iBAAiBA,CAACE,EAAE,EAAE;EAC7B,IAAIgB,KAAK,GAAG,EAAE;IACZC,KAAK,GAAG,EAAE;IACVC,KAAK,GAAG,EAAE;EAEZlB,EAAE,CAACG,QAAQ,CAACC,OAAO,CAAEF,QAAQ,IAAK;IAChC,IAAIA,QAAQ,CAACP,IAAI,KAAKtB,KAAK,EAAE;MAC3B;MACA2C,KAAK,GAAGf,eAAe,CAACC,QAAQ,CAAC;IACnC,CAAC,MAAM,IAAIA,QAAQ,CAACP,IAAI,KAAKrB,KAAK,EAAE;MAClC4C,KAAK,GAAGjB,eAAe,CAACC,QAAQ,CAAC;IACnC,CAAC,MAAM,IAAIA,QAAQ,CAACP,IAAI,KAAKpB,KAAK,EAAE;MAClC;MACA0C,KAAK,GAAGhB,eAAe,CAACC,QAAQ,CAAC;IACnC;EACF,CAAC,CAAC;EAEF,MAAMtB,IAAI,GAAG,CAAC,GAAGoC,KAAK,EAAE,GAAGE,KAAK,EAAE,GAAGD,KAAK,CAAC;EAE3C,OAAOrC,IAAI;AACb","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}