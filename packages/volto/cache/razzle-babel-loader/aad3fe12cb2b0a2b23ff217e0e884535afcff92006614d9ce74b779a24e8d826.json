{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\n// import { isWhitespace } from '@plone/volto-slate/utils';\nimport { TD, TH, COMMENT, ELEMENT_NODE, TEXT_NODE } from '../constants';\nimport { collapseInlineSpace } from './utils';\n\n/**\n * Deserialize to a Slate Node, an Array of Slate Nodes or null\n *\n * One particularity of this function is that it tries to do\n * a \"perception-based\" conversion. For example, in html, multiple whitespaces\n * display as a single space. A new line character in text is actually rendered\n * as a space, etc. So we try to meet user's expectations that when they\n * copy/paste content, we'll preserve the aspect of their text.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n */\nexport const deserialize = (editor, el, options = {\n  collapseWhitespace: true\n}) => {\n  const {\n    htmlTagsToSlate\n  } = editor;\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    const text = options.collapseWhitespace ? collapseInlineSpace(el) : el.textContent;\n    return text ? {\n      text\n    } : null;\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // gets merged with sibling text nodes by Slate normalization in insertData\n    return {\n      text: '\\n'\n    };\n  }\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el, options);\n  }\n  const {\n    nodeName\n  } = el;\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el, options);\n  }\n\n  // fallback deserializer, all unknown elements are \"stripped\"\n  return deserializeChildren(el, editor, options);\n};\nexport const typeDeserialize = (editor, el, options) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const {\n    type,\n    data\n  } = JSON.parse(jsData);\n  return jsx('element', {\n    type,\n    data\n  }, deserializeChildren(el, editor, options));\n};\nexport const deserializeChildren = (parent, editor, options) => Array.from(parent.childNodes).map(el => deserialize(editor, el, options)).flat();\nexport const blockTagDeserializer = tagname => (editor, el, options) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor, options).filter(n => n !== null);\n  if ([TD, TH].includes(tagname) && children.length > 0 && typeof children[0] === 'string') {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = {\n      type: 'div',\n      children: [{\n        text: ''\n      }]\n    };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find(c => !!c);\n  if (!hasValidChildren) {\n    children = [{\n      text: ''\n    }];\n  }\n  return jsx('element', {\n    type: tagname\n  }, children);\n};\nexport const bodyTagDeserializer = (editor, el, options) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor, options));\n};\nexport const inlineTagDeserializer = attrs => (editor, el, options) => {\n  return deserializeChildren(el, editor, options).map(child => {\n    const res = Text.isText(child) || typeof child === 'string' ? jsx('text', attrs, child) : _objectSpread(_objectSpread({}, child), {}, {\n      attrs // pass the inline attrs as separate object\n    });\n    return res;\n  });\n};\nexport const spanTagDeserializer = (editor, el, options) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n  if (\n  // handle formatting from OpenOffice\n  children.length === 1 && children[0].nodeType === TEXT_NODE && children[0].textContent === '\\n') {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor, options);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map(c => c === null ? '' : c);\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = {\n      sub: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = {\n      sup: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  }\n  const res = children.find(c => typeof c !== 'string') ? children : jsx('text', {}, children);\n  return res;\n};\nexport const bTagDeserializer = (editor, el, options) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1 ? deserializeChildren(el, editor, options) : jsx('element', {\n    type: 'b'\n  }, deserializeChildren(el, editor, options));\n};\nexport const codeTagDeserializer = (editor, el, options) => {\n  return jsx('element', {\n    type: 'code'\n  }, el.textContent);\n};\nexport const preTagDeserializer = (editor, el, options) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const {\n    nodeName\n  } = el;\n  let parent = el;\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent, options);\n  }\n  return blockTagDeserializer(nodeName)(editor, parent, options);\n};\nexport default deserialize;","map":{"version":3,"names":["jsx","Text","TD","TH","COMMENT","ELEMENT_NODE","TEXT_NODE","collapseInlineSpace","deserialize","editor","el","options","collapseWhitespace","htmlTagsToSlate","nodeType","text","textContent","nodeName","getAttribute","typeDeserialize","deserializeChildren","jsData","type","data","JSON","parse","parent","Array","from","childNodes","map","flat","blockTagDeserializer","tagname","children","filter","n","includes","length","p","hasValidChildren","find","c","bodyTagDeserializer","inlineTagDeserializer","attrs","child","res","isText","_objectSpread","spanTagDeserializer","style","replace","indexOf","sub","sup","bTagDeserializer","codeTagDeserializer","preTagDeserializer"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/deserialize.js"],"sourcesContent":["import { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\n// import { isWhitespace } from '@plone/volto-slate/utils';\nimport { TD, TH, COMMENT, ELEMENT_NODE, TEXT_NODE } from '../constants';\n\nimport { collapseInlineSpace } from './utils';\n\n/**\n * Deserialize to a Slate Node, an Array of Slate Nodes or null\n *\n * One particularity of this function is that it tries to do\n * a \"perception-based\" conversion. For example, in html, multiple whitespaces\n * display as a single space. A new line character in text is actually rendered\n * as a space, etc. So we try to meet user's expectations that when they\n * copy/paste content, we'll preserve the aspect of their text.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n */\nexport const deserialize = (\n  editor,\n  el,\n  options = { collapseWhitespace: true },\n) => {\n  const { htmlTagsToSlate } = editor;\n\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    const text = options.collapseWhitespace\n      ? collapseInlineSpace(el)\n      : el.textContent;\n    return text\n      ? {\n          text,\n        }\n      : null;\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // gets merged with sibling text nodes by Slate normalization in insertData\n    return { text: '\\n' };\n  }\n\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el, options);\n  }\n\n  const { nodeName } = el;\n\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el, options);\n  }\n\n  // fallback deserializer, all unknown elements are \"stripped\"\n  return deserializeChildren(el, editor, options);\n};\n\nexport const typeDeserialize = (editor, el, options) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const { type, data } = JSON.parse(jsData);\n  return jsx(\n    'element',\n    { type, data },\n    deserializeChildren(el, editor, options),\n  );\n};\n\nexport const deserializeChildren = (parent, editor, options) =>\n  Array.from(parent.childNodes)\n    .map((el) => deserialize(editor, el, options))\n    .flat();\n\nexport const blockTagDeserializer = (tagname) => (editor, el, options) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor, options).filter(\n    (n) => n !== null,\n  );\n\n  if (\n    [TD, TH].includes(tagname) &&\n    children.length > 0 &&\n    typeof children[0] === 'string'\n  ) {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = { type: 'div', children: [{ text: '' }] };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find((c) => !!c);\n  if (!hasValidChildren) {\n    children = [{ text: '' }];\n  }\n\n  return jsx('element', { type: tagname }, children);\n};\n\nexport const bodyTagDeserializer = (editor, el, options) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor, options));\n};\n\nexport const inlineTagDeserializer = (attrs) => (editor, el, options) => {\n  return deserializeChildren(el, editor, options).map((child) => {\n    const res =\n      Text.isText(child) || typeof child === 'string'\n        ? jsx('text', attrs, child)\n        : {\n            ...child,\n            attrs, // pass the inline attrs as separate object\n          };\n    return res;\n  });\n};\n\nexport const spanTagDeserializer = (editor, el, options) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n\n  if (\n    // handle formatting from OpenOffice\n    children.length === 1 &&\n    children[0].nodeType === TEXT_NODE &&\n    children[0].textContent === '\\n'\n  ) {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor, options);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map((c) => (c === null ? '' : c));\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = { sub: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = { sup: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  const res = children.find((c) => typeof c !== 'string')\n    ? children\n    : jsx('text', {}, children);\n\n  return res;\n};\n\nexport const bTagDeserializer = (editor, el, options) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1\n    ? deserializeChildren(el, editor, options)\n    : jsx('element', { type: 'b' }, deserializeChildren(el, editor, options));\n};\n\nexport const codeTagDeserializer = (editor, el, options) => {\n  return jsx('element', { type: 'code' }, el.textContent);\n};\n\nexport const preTagDeserializer = (editor, el, options) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const { nodeName } = el;\n  let parent = el;\n\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent, options);\n  }\n\n  return blockTagDeserializer(nodeName)(editor, parent, options);\n};\n\nexport default deserialize;\n"],"mappings":";;;;;AAAA,SAASA,GAAG,QAAQ,mBAAmB;AACvC,SAASC,IAAI,QAAQ,OAAO;AAC5B;AACA,SAASC,EAAE,EAAEC,EAAE,EAAEC,OAAO,EAAEC,YAAY,EAAEC,SAAS,QAAQ,cAAc;AAEvE,SAASC,mBAAmB,QAAQ,SAAS;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CACzBC,MAAM,EACNC,EAAE,EACFC,OAAO,GAAG;EAAEC,kBAAkB,EAAE;AAAK,CAAC,KACnC;EACH,MAAM;IAAEC;EAAgB,CAAC,GAAGJ,MAAM;EAElC,IAAIC,EAAE,CAACI,QAAQ,KAAKV,OAAO,EAAE;IAC3B,OAAO,IAAI;EACb,CAAC,MAAM,IAAIM,EAAE,CAACI,QAAQ,KAAKR,SAAS,EAAE;IACpC,MAAMS,IAAI,GAAGJ,OAAO,CAACC,kBAAkB,GACnCL,mBAAmB,CAACG,EAAE,CAAC,GACvBA,EAAE,CAACM,WAAW;IAClB,OAAOD,IAAI,GACP;MACEA;IACF,CAAC,GACD,IAAI;EACV,CAAC,MAAM,IAAIL,EAAE,CAACI,QAAQ,KAAKT,YAAY,EAAE;IACvC,OAAO,IAAI;EACb,CAAC,MAAM,IAAIK,EAAE,CAACO,QAAQ,KAAK,IAAI,EAAE;IAC/B;IACA,OAAO;MAAEF,IAAI,EAAE;IAAK,CAAC;EACvB;EAEA,IAAIL,EAAE,CAACQ,YAAY,CAAC,iBAAiB,CAAC,EAAE;IACtC,OAAOC,eAAe,CAACV,MAAM,EAAEC,EAAE,EAAEC,OAAO,CAAC;EAC7C;EAEA,MAAM;IAAEM;EAAS,CAAC,GAAGP,EAAE;EAEvB,IAAIG,eAAe,CAACI,QAAQ,CAAC,EAAE;IAC7B,OAAOJ,eAAe,CAACI,QAAQ,CAAC,CAACR,MAAM,EAAEC,EAAE,EAAEC,OAAO,CAAC;EACvD;;EAEA;EACA,OAAOS,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC;AACjD,CAAC;AAED,OAAO,MAAMQ,eAAe,GAAGA,CAACV,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACtD,MAAMU,MAAM,GAAGX,EAAE,CAACQ,YAAY,CAAC,iBAAiB,CAAC;EACjD,MAAM;IAAEI,IAAI;IAAEC;EAAK,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACJ,MAAM,CAAC;EACzC,OAAOrB,GAAG,CACR,SAAS,EACT;IAAEsB,IAAI;IAAEC;EAAK,CAAC,EACdH,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CACzC,CAAC;AACH,CAAC;AAED,OAAO,MAAMS,mBAAmB,GAAGA,CAACM,MAAM,EAAEjB,MAAM,EAAEE,OAAO,KACzDgB,KAAK,CAACC,IAAI,CAACF,MAAM,CAACG,UAAU,CAAC,CAC1BC,GAAG,CAAEpB,EAAE,IAAKF,WAAW,CAACC,MAAM,EAAEC,EAAE,EAAEC,OAAO,CAAC,CAAC,CAC7CoB,IAAI,CAAC,CAAC;AAEX,OAAO,MAAMC,oBAAoB,GAAIC,OAAO,IAAK,CAACxB,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACxE;EACA,IAAIuB,QAAQ,GAAGd,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC,CAACwB,MAAM,CAC3DC,CAAC,IAAKA,CAAC,KAAK,IACf,CAAC;EAED,IACE,CAAClC,EAAE,EAAEC,EAAE,CAAC,CAACkC,QAAQ,CAACJ,OAAO,CAAC,IAC1BC,QAAQ,CAACI,MAAM,GAAG,CAAC,IACnB,OAAOJ,QAAQ,CAAC,CAAC,CAAC,KAAK,QAAQ,EAC/B;IACA;IACA;IACA,MAAMK,CAAC,GAAG;MAAEjB,IAAI,EAAE,KAAK;MAAEY,QAAQ,EAAE,CAAC;QAAEnB,IAAI,EAAE;MAAG,CAAC;IAAE,CAAC;IACnDwB,CAAC,CAACL,QAAQ,CAAC,CAAC,CAAC,CAACnB,IAAI,GAAGmB,QAAQ,CAAC,CAAC,CAAC;IAChCA,QAAQ,GAAG,CAACK,CAAC,CAAC;EAChB;;EAEA;EACA;EACA,MAAMC,gBAAgB,GAAGN,QAAQ,CAACI,MAAM,IAAIJ,QAAQ,CAACO,IAAI,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC;EACrE,IAAI,CAACF,gBAAgB,EAAE;IACrBN,QAAQ,GAAG,CAAC;MAAEnB,IAAI,EAAE;IAAG,CAAC,CAAC;EAC3B;EAEA,OAAOf,GAAG,CAAC,SAAS,EAAE;IAAEsB,IAAI,EAAEW;EAAQ,CAAC,EAAEC,QAAQ,CAAC;AACpD,CAAC;AAED,OAAO,MAAMS,mBAAmB,GAAGA,CAAClC,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EAC1D,OAAOX,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,EAAEoB,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC,CAAC;AACtE,CAAC;AAED,OAAO,MAAMiC,qBAAqB,GAAIC,KAAK,IAAK,CAACpC,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACvE,OAAOS,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC,CAACmB,GAAG,CAAEgB,KAAK,IAAK;IAC7D,MAAMC,GAAG,GACP9C,IAAI,CAAC+C,MAAM,CAACF,KAAK,CAAC,IAAI,OAAOA,KAAK,KAAK,QAAQ,GAC3C9C,GAAG,CAAC,MAAM,EAAE6C,KAAK,EAAEC,KAAK,CAAC,GAAAG,aAAA,CAAAA,aAAA,KAEpBH,KAAK;MACRD,KAAK,CAAE;IAAA,EACR;IACP,OAAOE,GAAG;EACZ,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,MAAMG,mBAAmB,GAAGA,CAACzC,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EAC1D,MAAMwC,KAAK,GAAGzC,EAAE,CAACQ,YAAY,CAAC,OAAO,CAAC,IAAI,EAAE;EAC5C,IAAIgB,QAAQ,GAAGxB,EAAE,CAACmB,UAAU;EAE5B;EACE;EACAK,QAAQ,CAACI,MAAM,KAAK,CAAC,IACrBJ,QAAQ,CAAC,CAAC,CAAC,CAACpB,QAAQ,KAAKR,SAAS,IAClC4B,QAAQ,CAAC,CAAC,CAAC,CAAClB,WAAW,KAAK,IAAI,EAChC;IACA,OAAOhB,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC;EAC7B;EACAkC,QAAQ,GAAGd,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC;;EAEnD;EACAuB,QAAQ,GAAGA,QAAQ,CAACJ,GAAG,CAAEY,CAAC,IAAMA,CAAC,KAAK,IAAI,GAAG,EAAE,GAAGA,CAAE,CAAC;;EAErD;EACA;EACA,IAAIS,KAAK,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,OAAO,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,EAAE;IAC/D,MAAMR,KAAK,GAAG;MAAES,GAAG,EAAE;IAAK,CAAC;IAC3B,OAAOpB,QAAQ,CAACJ,GAAG,CAAEgB,KAAK,IAAK;MAC7B,OAAO9C,GAAG,CAAC,MAAM,EAAE6C,KAAK,EAAEC,KAAK,CAAC;IAClC,CAAC,CAAC;EACJ;;EAEA;EACA,IAAIK,KAAK,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,OAAO,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC,EAAE;IACjE,MAAMR,KAAK,GAAG;MAAEU,GAAG,EAAE;IAAK,CAAC;IAC3B,OAAOrB,QAAQ,CAACJ,GAAG,CAAEgB,KAAK,IAAK;MAC7B,OAAO9C,GAAG,CAAC,MAAM,EAAE6C,KAAK,EAAEC,KAAK,CAAC;IAClC,CAAC,CAAC;EACJ;EAEA,MAAMC,GAAG,GAAGb,QAAQ,CAACO,IAAI,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC,GACnDR,QAAQ,GACRlC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,EAAEkC,QAAQ,CAAC;EAE7B,OAAOa,GAAG;AACZ,CAAC;AAED,OAAO,MAAMS,gBAAgB,GAAGA,CAAC/C,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACvD;EACA,OAAO,CAACD,EAAE,CAACQ,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,EAAEmC,OAAO,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,GACnEjC,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC,GACxCX,GAAG,CAAC,SAAS,EAAE;IAAEsB,IAAI,EAAE;EAAI,CAAC,EAAEF,mBAAmB,CAACV,EAAE,EAAED,MAAM,EAAEE,OAAO,CAAC,CAAC;AAC7E,CAAC;AAED,OAAO,MAAM8C,mBAAmB,GAAGA,CAAChD,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EAC1D,OAAOX,GAAG,CAAC,SAAS,EAAE;IAAEsB,IAAI,EAAE;EAAO,CAAC,EAAEZ,EAAE,CAACM,WAAW,CAAC;AACzD,CAAC;AAED,OAAO,MAAM0C,kBAAkB,GAAGA,CAACjD,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACzD;EACA;EACA;EACA,MAAM;IAAEM;EAAS,CAAC,GAAGP,EAAE;EACvB,IAAIgB,MAAM,GAAGhB,EAAE;EAEf,IAAIA,EAAE,CAACmB,UAAU,CAAC,CAAC,CAAC,IAAInB,EAAE,CAACmB,UAAU,CAAC,CAAC,CAAC,CAACZ,QAAQ,KAAK,MAAM,EAAE;IAC5DS,MAAM,GAAGhB,EAAE,CAACmB,UAAU,CAAC,CAAC,CAAC;IACzB,OAAO4B,mBAAmB,CAAChD,MAAM,EAAEiB,MAAM,EAAEf,OAAO,CAAC;EACrD;EAEA,OAAOqB,oBAAoB,CAACf,QAAQ,CAAC,CAACR,MAAM,EAAEiB,MAAM,EAAEf,OAAO,CAAC;AAChE,CAAC;AAED,eAAeH,WAAW","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}