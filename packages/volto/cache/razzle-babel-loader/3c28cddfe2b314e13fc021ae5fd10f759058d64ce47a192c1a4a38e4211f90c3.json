{"ast":null,"code":"import _extends from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/extends.js\";\nvar _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/Extensions/withBlockExtensions.jsx\";\nvar __jsx = React.createElement;\n/**\n * A HOC to inject a block extension by resolving the configured extension\n */\n\nimport React from 'react';\nimport config from '@plone/volto/registry';\n\n/**\n * Retrieves the extension (variation) settings from the provided\n * configuration, based on incoming data.\n */\nexport function resolveExtension(name, extensions, data) {\n  const selectedExtension = data[name];\n  let index = extensions.findIndex(conf => conf.id === selectedExtension);\n  if (index === -1) {\n    index = extensions.findIndex(conf => conf.isDefault);\n  }\n  return index !== -1 ? extensions[index] : undefined;\n}\n\n/**\n * A block can declare extensions and variations like:\n *\n * {\n *  variations: [\n *    {\n *      id: \"summary\",\n *      isDefault: true,\n *      template: Something\n *    }\n *  ],\n *  extensions: {\n *    'extensionA': {\n *      items: [\n *        // something similar to variations\n *      ]\n *    }\n *  }\n * }\n *\n * Exactly what an extension and what a variation represent is only up to the\n * block. A block should incorporate these extension mechanisms and it should\n * define what information is needed from them.\n *\n * resolveBlockExtensions will return an object with\n * `{ extensions, resolvedExtensions}`, where:\n *\n * - extensions is the blocksConfig extensions object for that block\n * - resolvedExtensions is an object with\n *   `{ variation, <someExtensionA>, <someExtensionB> }` and each of these\n *   fields hold the corresponding definition object from the block's\n *   configuration.\n */\nexport function resolveBlockExtensions(data, blocksConfig) {\n  const block_type = data['@type'];\n  const {\n    extensions = {},\n    variations = []\n  } = (blocksConfig === null || blocksConfig === void 0 ? void 0 : blocksConfig[block_type]) || config.blocks.blocksConfig[block_type];\n  const resolvedExtensions = Object.assign({}, ...Object.keys(extensions).map(extensionName => ({\n    [extensionName]: resolveExtension(extensionName, extensions[extensionName].items || [], data, block_type)\n  })));\n  if (variations.length) {\n    const variation = data.variation ? variations.find(({\n      id\n    }) => id === data.variation) : variations.find(({\n      isDefault\n    }) => isDefault);\n    resolvedExtensions.variation = variation;\n  }\n  return {\n    extensions,\n    resolvedExtensions\n  };\n}\nconst withBlockExtensions = WrappedComponent => props => {\n  const {\n    data,\n    blocksConfig\n  } = props;\n  const {\n    extensions,\n    resolvedExtensions\n  } = resolveBlockExtensions(data, blocksConfig);\n  return __jsx(WrappedComponent, _extends({}, resolvedExtensions, props, {\n    extensions: extensions,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 5\n    }\n  }));\n};\nexport default withBlockExtensions;","map":{"version":3,"names":["React","config","resolveExtension","name","extensions","data","selectedExtension","index","findIndex","conf","id","isDefault","undefined","resolveBlockExtensions","blocksConfig","block_type","variations","blocks","resolvedExtensions","Object","assign","keys","map","extensionName","items","length","variation","find","withBlockExtensions","WrappedComponent","props","__jsx","_extends","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/Extensions/withBlockExtensions.jsx"],"sourcesContent":["/**\n * A HOC to inject a block extension by resolving the configured extension\n */\n\nimport React from 'react';\nimport config from '@plone/volto/registry';\n\n/**\n * Retrieves the extension (variation) settings from the provided\n * configuration, based on incoming data.\n */\nexport function resolveExtension(name, extensions, data) {\n  const selectedExtension = data[name];\n\n  let index = extensions.findIndex((conf) => conf.id === selectedExtension);\n\n  if (index === -1) {\n    index = extensions.findIndex((conf) => conf.isDefault);\n  }\n\n  return index !== -1 ? extensions[index] : undefined;\n}\n\n/**\n * A block can declare extensions and variations like:\n *\n * {\n *  variations: [\n *    {\n *      id: \"summary\",\n *      isDefault: true,\n *      template: Something\n *    }\n *  ],\n *  extensions: {\n *    'extensionA': {\n *      items: [\n *        // something similar to variations\n *      ]\n *    }\n *  }\n * }\n *\n * Exactly what an extension and what a variation represent is only up to the\n * block. A block should incorporate these extension mechanisms and it should\n * define what information is needed from them.\n *\n * resolveBlockExtensions will return an object with\n * `{ extensions, resolvedExtensions}`, where:\n *\n * - extensions is the blocksConfig extensions object for that block\n * - resolvedExtensions is an object with\n *   `{ variation, <someExtensionA>, <someExtensionB> }` and each of these\n *   fields hold the corresponding definition object from the block's\n *   configuration.\n */\nexport function resolveBlockExtensions(data, blocksConfig) {\n  const block_type = data['@type'];\n\n  const { extensions = {}, variations = [] } =\n    blocksConfig?.[block_type] || config.blocks.blocksConfig[block_type];\n\n  const resolvedExtensions = Object.assign(\n    {},\n    ...Object.keys(extensions).map((extensionName) => ({\n      [extensionName]: resolveExtension(\n        extensionName,\n        extensions[extensionName].items || [],\n        data,\n        block_type,\n      ),\n    })),\n  );\n\n  if (variations.length) {\n    const variation = data.variation\n      ? variations.find(({ id }) => id === data.variation)\n      : variations.find(({ isDefault }) => isDefault);\n    resolvedExtensions.variation = variation;\n  }\n\n  return { extensions, resolvedExtensions };\n}\n\nconst withBlockExtensions = (WrappedComponent) => (props) => {\n  const { data, blocksConfig } = props;\n\n  const { extensions, resolvedExtensions } = resolveBlockExtensions(\n    data,\n    blocksConfig,\n  );\n  return (\n    <WrappedComponent\n      {...resolvedExtensions}\n      {...props}\n      extensions={extensions}\n    />\n  );\n};\n\nexport default withBlockExtensions;\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,IAAI,EAAEC,UAAU,EAAEC,IAAI,EAAE;EACvD,MAAMC,iBAAiB,GAAGD,IAAI,CAACF,IAAI,CAAC;EAEpC,IAAII,KAAK,GAAGH,UAAU,CAACI,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACC,EAAE,KAAKJ,iBAAiB,CAAC;EAEzE,IAAIC,KAAK,KAAK,CAAC,CAAC,EAAE;IAChBA,KAAK,GAAGH,UAAU,CAACI,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACE,SAAS,CAAC;EACxD;EAEA,OAAOJ,KAAK,KAAK,CAAC,CAAC,GAAGH,UAAU,CAACG,KAAK,CAAC,GAAGK,SAAS;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsBA,CAACR,IAAI,EAAES,YAAY,EAAE;EACzD,MAAMC,UAAU,GAAGV,IAAI,CAAC,OAAO,CAAC;EAEhC,MAAM;IAAED,UAAU,GAAG,CAAC,CAAC;IAAEY,UAAU,GAAG;EAAG,CAAC,GACxC,CAAAF,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAGC,UAAU,CAAC,KAAId,MAAM,CAACgB,MAAM,CAACH,YAAY,CAACC,UAAU,CAAC;EAEtE,MAAMG,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CACtC,CAAC,CAAC,EACF,GAAGD,MAAM,CAACE,IAAI,CAACjB,UAAU,CAAC,CAACkB,GAAG,CAAEC,aAAa,KAAM;IACjD,CAACA,aAAa,GAAGrB,gBAAgB,CAC/BqB,aAAa,EACbnB,UAAU,CAACmB,aAAa,CAAC,CAACC,KAAK,IAAI,EAAE,EACrCnB,IAAI,EACJU,UACF;EACF,CAAC,CAAC,CACJ,CAAC;EAED,IAAIC,UAAU,CAACS,MAAM,EAAE;IACrB,MAAMC,SAAS,GAAGrB,IAAI,CAACqB,SAAS,GAC5BV,UAAU,CAACW,IAAI,CAAC,CAAC;MAAEjB;IAAG,CAAC,KAAKA,EAAE,KAAKL,IAAI,CAACqB,SAAS,CAAC,GAClDV,UAAU,CAACW,IAAI,CAAC,CAAC;MAAEhB;IAAU,CAAC,KAAKA,SAAS,CAAC;IACjDO,kBAAkB,CAACQ,SAAS,GAAGA,SAAS;EAC1C;EAEA,OAAO;IAAEtB,UAAU;IAAEc;EAAmB,CAAC;AAC3C;AAEA,MAAMU,mBAAmB,GAAIC,gBAAgB,IAAMC,KAAK,IAAK;EAC3D,MAAM;IAAEzB,IAAI;IAAES;EAAa,CAAC,GAAGgB,KAAK;EAEpC,MAAM;IAAE1B,UAAU;IAAEc;EAAmB,CAAC,GAAGL,sBAAsB,CAC/DR,IAAI,EACJS,YACF,CAAC;EACD,OACEiB,KAAA,CAACF,gBAAgB,EAAAG,QAAA,KACXd,kBAAkB,EAClBY,KAAK;IACT1B,UAAU,EAAEA,UAAW;IAAA6B,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,EACxB,CAAC;AAEN,CAAC;AAED,eAAeV,mBAAmB","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}