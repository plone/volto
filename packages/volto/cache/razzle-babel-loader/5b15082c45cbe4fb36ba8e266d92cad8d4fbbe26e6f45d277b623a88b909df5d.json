{"ast":null,"code":"import { INLINE_ELEMENTS, TEXT_NODE } from '../constants';\n\n// Original at https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n/**\n * Throughout, whitespace is defined as one of the characters\n *  \"\\t\" TAB \\u0009\n *  \"\\n\" LF  \\u000A\n *  \"\\r\" CR  \\u000D\n *  \" \"  SPC \\u0020\n *\n * This does not use JavaScript's \"\\s\" because that includes non-breaking\n * spaces (and also some other characters).\n */\n\n/**\n * Determine whether a node's text content is entirely whitespace.\n *\n * @param nod  A node implementing the |CharacterData| interface (i.e.,\n *             a |Text|, |Comment|, or |CDATASection| node\n * @return     True if all of the text content of |nod| is whitespace,\n *             otherwise false.\n */\nexport function is_all_ws(text) {\n  return !/[^\\t\\n\\r ]/.test(text);\n}\n\n/**\n * Version of |data| that doesn't include whitespace at the beginning\n * and end and normalizes all whitespace to a single space. (Normally\n * |data| is a property of text nodes that gives the text of the node.)\n *\n * @param txt  The text node whose data should be returned\n * @return     A string giving the contents of the text node with\n *             whitespace collapsed.\n */\nexport function data_of(txt) {\n  let data = txt.textContent;\n  data = data.replace(/[\\t\\n\\r ]+/g, ' ');\n  if (data[0] === ' ') {\n    data = data.substring(1, data.length);\n  }\n  if (data[data.length - 1] === ' ') {\n    data = data.substring(0, data.length - 1);\n  }\n  return data;\n}\n\n/**\n * Determine if a node should be ignored by the iterator functions.\n *\n * @param nod  An object implementing the DOM1 |Node| interface.\n * @return     true if the node is:\n *                1) A |Text| node that is all whitespace\n *                2) A |Comment| node\n *             and otherwise false.\n */\n\nexport function is_ignorable(nod) {\n  return nod.nodeType === 8 ||\n  // A comment node\n  nod.nodeType === 3 && is_all_ws(nod.textContent); // a text node, all ws\n}\n\n/**\n * Version of |previousSibling| that skips nodes that are entirely\n * whitespace or comments. (Normally |previousSibling| is a property\n * of all DOM nodes that gives the sibling node, the node that is\n * a child of the same parent, that occurs immediately before the\n * reference node.)\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The closest previous sibling to |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function node_before(sib) {\n  while (sib = sib.previousSibling) {\n    if (!is_ignorable(sib)) {\n      return sib;\n    }\n  }\n  return null;\n}\n\n/**\n * Version of |nextSibling| that skips nodes that are entirely\n * whitespace or comments.\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The closest next sibling to |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function node_after(sib) {\n  while (sib = sib.nextSibling) {\n    if (!is_ignorable(sib)) {\n      return sib;\n    }\n  }\n  return null;\n}\n\n/**\n * Version of |lastChild| that skips nodes that are entirely\n * whitespace or comments. (Normally |lastChild| is a property\n * of all DOM nodes that gives the last of the nodes contained\n * directly in the reference node.)\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The last child of |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function last_child(par) {\n  let res = par.lastChild;\n  while (res) {\n    if (!is_ignorable(res)) {\n      return res;\n    }\n    res = res.previousSibling;\n  }\n  return null;\n}\n\n/**\n * Version of |firstChild| that skips nodes that are entirely\n * whitespace and comments.\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The first child of |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function first_child(par) {\n  let res = par.firstChild;\n  while (res) {\n    if (!is_ignorable(res)) {\n      return res;\n    }\n    res = res.nextSibling;\n  }\n  return null;\n}\nexport const removeSpaceBeforeAfterEndLine = text => {\n  text = text.replace(/\\s+\\n/gm, '\\n'); // space before endline\n  text = text.replace(/\\n\\s+/gm, '\\n'); // space after endline\n  return text;\n};\nexport const convertTabsToSpaces = text => text.replace(/\\t/gm, ' ');\nexport const convertLineBreaksToSpaces = text => text.replace(/\\n/gm, ' ');\nexport const isInline = node => node && (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\nexport const removeSpaceFollowSpace = (text, node) => {\n  // Any space immediately following another space (even across two separate\n  // inline elements) is ignored (rule 4)\n  text = text.replace(/ ( +)/gm, ' ');\n  if (!text.startsWith(' ')) return text;\n  if (node.previousSibling) {\n    if (node.previousSibling.nodeType === TEXT_NODE) {\n      if (node.previousSibling.textContent.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    } else if (isInline(node.previousSibling)) {\n      const prevText = collapseInlineSpace(node.previousSibling);\n      if (prevText.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    }\n  } else {\n    const parent = node.parentNode;\n    if (parent.previousSibling) {\n      //  && isInline(parent.previousSibling)\n      const prevText = collapseInlineSpace(parent.previousSibling);\n      if (prevText && prevText.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    }\n  }\n  return text;\n};\nexport const removeElementEdges = (text, node) => {\n  if (!isInline(node.parentNode) && !node.previousSibling && text.match(/^\\s/)) {\n    text = text.replace(/^\\s+/, '');\n  }\n  if (text.match(/\\s$/) && !node.nextSibling && !isInline(node.parentNode)) {\n    text = text.replace(/\\s$/, '');\n  }\n  return text;\n};\nexport const collapseInlineSpace = node => {\n  let text = node.textContent;\n\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n\n  // 1. all spaces and tabs immediately before and after a line break are ignored\n\n  text = removeSpaceBeforeAfterEndLine(text);\n\n  // 2. Next, all tab characters are handled as space characters\n  text = convertTabsToSpaces(text);\n\n  // 3. Convert all line breaks to spaces\n  text = convertLineBreaksToSpaces(text);\n\n  // 4. Any space immediately following another space\n  // (even across two separate inline elements) is ignored\n  text = removeSpaceFollowSpace(text, node);\n\n  // 5. Sequences of spaces at the beginning and end of an element are removed\n  text = removeElementEdges(text, node);\n\n  // (volto) Return null if the element is not adjacent to an inline node\n  // This will cause the element to be ignored in the deserialization\n  // TODO: use the node traverse functions defined here\n  if (is_all_ws(text) && !(isInline(node.previousSibling) || isInline(node.nextSibling) || isInline(node.parentNode.nextSibling) || isInline(node.parentNode.previousSibling))) {\n    return null;\n  }\n  return text;\n};","map":{"version":3,"names":["INLINE_ELEMENTS","TEXT_NODE","is_all_ws","text","test","data_of","txt","data","textContent","replace","substring","length","is_ignorable","nod","nodeType","node_before","sib","previousSibling","node_after","nextSibling","last_child","par","res","lastChild","first_child","firstChild","removeSpaceBeforeAfterEndLine","convertTabsToSpaces","convertLineBreaksToSpaces","isInline","node","includes","nodeName","removeSpaceFollowSpace","startsWith","endsWith","prevText","collapseInlineSpace","parent","parentNode","removeElementEdges","match"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/utils.js"],"sourcesContent":["import { INLINE_ELEMENTS, TEXT_NODE } from '../constants';\n\n// Original at https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n/**\n * Throughout, whitespace is defined as one of the characters\n *  \"\\t\" TAB \\u0009\n *  \"\\n\" LF  \\u000A\n *  \"\\r\" CR  \\u000D\n *  \" \"  SPC \\u0020\n *\n * This does not use JavaScript's \"\\s\" because that includes non-breaking\n * spaces (and also some other characters).\n */\n\n/**\n * Determine whether a node's text content is entirely whitespace.\n *\n * @param nod  A node implementing the |CharacterData| interface (i.e.,\n *             a |Text|, |Comment|, or |CDATASection| node\n * @return     True if all of the text content of |nod| is whitespace,\n *             otherwise false.\n */\nexport function is_all_ws(text) {\n  return !/[^\\t\\n\\r ]/.test(text);\n}\n\n/**\n * Version of |data| that doesn't include whitespace at the beginning\n * and end and normalizes all whitespace to a single space. (Normally\n * |data| is a property of text nodes that gives the text of the node.)\n *\n * @param txt  The text node whose data should be returned\n * @return     A string giving the contents of the text node with\n *             whitespace collapsed.\n */\nexport function data_of(txt) {\n  let data = txt.textContent;\n  data = data.replace(/[\\t\\n\\r ]+/g, ' ');\n  if (data[0] === ' ') {\n    data = data.substring(1, data.length);\n  }\n  if (data[data.length - 1] === ' ') {\n    data = data.substring(0, data.length - 1);\n  }\n  return data;\n}\n\n/**\n * Determine if a node should be ignored by the iterator functions.\n *\n * @param nod  An object implementing the DOM1 |Node| interface.\n * @return     true if the node is:\n *                1) A |Text| node that is all whitespace\n *                2) A |Comment| node\n *             and otherwise false.\n */\n\nexport function is_ignorable(nod) {\n  return (\n    nod.nodeType === 8 || // A comment node\n    (nod.nodeType === 3 && is_all_ws(nod.textContent))\n  ); // a text node, all ws\n}\n\n/**\n * Version of |previousSibling| that skips nodes that are entirely\n * whitespace or comments. (Normally |previousSibling| is a property\n * of all DOM nodes that gives the sibling node, the node that is\n * a child of the same parent, that occurs immediately before the\n * reference node.)\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The closest previous sibling to |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function node_before(sib) {\n  while ((sib = sib.previousSibling)) {\n    if (!is_ignorable(sib)) {\n      return sib;\n    }\n  }\n  return null;\n}\n\n/**\n * Version of |nextSibling| that skips nodes that are entirely\n * whitespace or comments.\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The closest next sibling to |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function node_after(sib) {\n  while ((sib = sib.nextSibling)) {\n    if (!is_ignorable(sib)) {\n      return sib;\n    }\n  }\n  return null;\n}\n\n/**\n * Version of |lastChild| that skips nodes that are entirely\n * whitespace or comments. (Normally |lastChild| is a property\n * of all DOM nodes that gives the last of the nodes contained\n * directly in the reference node.)\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The last child of |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function last_child(par) {\n  let res = par.lastChild;\n  while (res) {\n    if (!is_ignorable(res)) {\n      return res;\n    }\n    res = res.previousSibling;\n  }\n  return null;\n}\n\n/**\n * Version of |firstChild| that skips nodes that are entirely\n * whitespace and comments.\n *\n * @param sib  The reference node.\n * @return     Either:\n *               1) The first child of |sib| that is not\n *                  ignorable according to |is_ignorable|, or\n *               2) null if no such node exists.\n */\nexport function first_child(par) {\n  let res = par.firstChild;\n  while (res) {\n    if (!is_ignorable(res)) {\n      return res;\n    }\n    res = res.nextSibling;\n  }\n  return null;\n}\n\nexport const removeSpaceBeforeAfterEndLine = (text) => {\n  text = text.replace(/\\s+\\n/gm, '\\n'); // space before endline\n  text = text.replace(/\\n\\s+/gm, '\\n'); // space after endline\n  return text;\n};\n\nexport const convertTabsToSpaces = (text) => text.replace(/\\t/gm, ' ');\nexport const convertLineBreaksToSpaces = (text) => text.replace(/\\n/gm, ' ');\n\nexport const isInline = (node) =>\n  node &&\n  (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n\nexport const removeSpaceFollowSpace = (text, node) => {\n  // Any space immediately following another space (even across two separate\n  // inline elements) is ignored (rule 4)\n  text = text.replace(/ ( +)/gm, ' ');\n  if (!text.startsWith(' ')) return text;\n\n  if (node.previousSibling) {\n    if (node.previousSibling.nodeType === TEXT_NODE) {\n      if (node.previousSibling.textContent.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    } else if (isInline(node.previousSibling)) {\n      const prevText = collapseInlineSpace(node.previousSibling);\n      if (prevText.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    }\n  } else {\n    const parent = node.parentNode;\n    if (parent.previousSibling) {\n      //  && isInline(parent.previousSibling)\n      const prevText = collapseInlineSpace(parent.previousSibling);\n      if (prevText && prevText.endsWith(' ')) {\n        return text.replace(/^ /, '');\n      }\n    }\n  }\n\n  return text;\n};\n\nexport const removeElementEdges = (text, node) => {\n  if (\n    !isInline(node.parentNode) &&\n    !node.previousSibling &&\n    text.match(/^\\s/)\n  ) {\n    text = text.replace(/^\\s+/, '');\n  }\n\n  if (text.match(/\\s$/) && !node.nextSibling && !isInline(node.parentNode)) {\n    text = text.replace(/\\s$/, '');\n  }\n\n  return text;\n};\n\nexport const collapseInlineSpace = (node) => {\n  let text = node.textContent;\n\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n\n  // 1. all spaces and tabs immediately before and after a line break are ignored\n\n  text = removeSpaceBeforeAfterEndLine(text);\n\n  // 2. Next, all tab characters are handled as space characters\n  text = convertTabsToSpaces(text);\n\n  // 3. Convert all line breaks to spaces\n  text = convertLineBreaksToSpaces(text);\n\n  // 4. Any space immediately following another space\n  // (even across two separate inline elements) is ignored\n  text = removeSpaceFollowSpace(text, node);\n\n  // 5. Sequences of spaces at the beginning and end of an element are removed\n  text = removeElementEdges(text, node);\n\n  // (volto) Return null if the element is not adjacent to an inline node\n  // This will cause the element to be ignored in the deserialization\n  // TODO: use the node traverse functions defined here\n  if (\n    is_all_ws(text) &&\n    !(\n      isInline(node.previousSibling) ||\n      isInline(node.nextSibling) ||\n      isInline(node.parentNode.nextSibling) ||\n      isInline(node.parentNode.previousSibling)\n    )\n  ) {\n    return null;\n  }\n\n  return text;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}