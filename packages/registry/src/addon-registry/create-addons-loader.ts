import fs from 'fs';
import path from 'path';
import tmp from 'tmp';
import cryptoRandomString from 'crypto-random-string';
import type { Package } from './addon-registry';

const titleCase = (w: string) =>
  w.slice(0, 1).toUpperCase() + w.slice(1, w.length);

/*
 * Transforms a package name to javascript variable name
 */
function nameFromPackage(name: string) {
  name =
    name.replace(/[@~./\\:\s]/gi, '') ||
    cryptoRandomString({ length: 10, characters: 'abcdefghijk' });
  return name
    .split('-')
    .map((w, i) => (i > 0 ? titleCase(w) : w))
    .join('');
}

/*
 * Creates a static file with code necessary to load the addons configuration
 *
 */
function getAddonsLoaderCode(
  addons: string[],
  addonsInfo: Package[],
  loadProjectConfig?: boolean,
) {
  let buf = `/*
This file is autogenerated. Don't change it directly.
Instead, change the "addons" setting in your package.json file.
*/

`;
  if (loadProjectConfig) {
    buf += `const projectConfigLoader = require('@root/config');\n`;
  }

  let configsToLoad: string[] = [],
    counter = 0;

  addons.forEach((addonConfigString) => {
    let extras: string[] | string[][] = []; // TODO: Improve this typing
    const addonConfigLoadInfo = addonConfigString.split(':');
    const pkgName = addonConfigLoadInfo[0];
    const defaultImport = nameFromPackage(pkgName);
    if (addonConfigLoadInfo.length > 1) {
      extras = addonConfigLoadInfo[1].split(',');
    }
    extras = extras.map((name) => [name, `${name}${counter++}`]);
    const line = `import ${defaultImport}${
      extras.length
        ? `, { ${extras
            .map((ex) => {
              return `${ex[0]} as ${ex[1]}`;
            })
            .join(', ')} }`
        : ''
    } from '${pkgName}';\n`;
    buf += line;
    configsToLoad = [
      ...configsToLoad,
      defaultImport,
      ...extras.map((ex) => ex[1]),
    ];
  });

  buf += `
${
  addonsInfo
    ? `const addonsInfo = ${JSON.stringify(addonsInfo)}`
    : 'const addonsInfo = {}'
};
export { addonsInfo };
`;

  buf += `
const safeWrapper = (func) => (config) => {
  const res = func(config);
  if (typeof res === 'undefined') {
    throw new Error("Configuration function doesn't return config");
  }
  return res;
}

${loadProjectConfig ? '' : 'const projectConfigLoader = false;'}
const projectConfig = (config) => {
  return projectConfigLoader && typeof projectConfigLoader.default === "function" ? projectConfigLoader.default(config) : config;
}

const load = (config) => {
  const addonLoaders = [${configsToLoad.join(', ')}];
  if(!addonLoaders.every((el) => typeof el === "function")) {
    throw new TypeError(
      'Each addon has to provide a function applying its configuration to the projects configuration.',
    );
  }
  return projectConfig(addonLoaders.reduce((acc, apply) => safeWrapper(apply)(acc), config));
};
export default load;
`;

  return buf;
}

export function createAddonsLoader(
  addons: string[],
  addonsInfo: Package[],
  {
    tempInProject,
    loadProjectConfig = false,
  }: { tempInProject?: boolean; loadProjectConfig?: boolean } = {},
) {
  // Some frameworks do not allow to load code from outside the project.
  // the `tempInProject` allows to place it inside
  let addonsLoaderPath: string;
  if (tempInProject) {
    addonsLoaderPath = path.join(process.cwd(), 'src', '.addons-loader.js');
  } else {
    addonsLoaderPath = tmp.tmpNameSync({ postfix: '.js' });
  }

  const code = getAddonsLoaderCode(addons, addonsInfo, loadProjectConfig);
  // @ts-expect-error No clue why it's complaining
  fs.writeFileSync(addonsLoaderPath, Buffer.from(code));
  return addonsLoaderPath;
}

export { getAddonsLoaderCode, nameFromPackage };
