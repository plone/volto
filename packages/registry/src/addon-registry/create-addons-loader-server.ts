import fs from 'fs';
import path from 'path';
import cryptoRandomString from 'crypto-random-string';
import type { Package } from './addon-registry';

const titleCase = (w: string) =>
  w.slice(0, 1).toUpperCase() + w.slice(1, w.length);

/*
 * Transforms a package name to javascript variable name
 */
function nameFromPackage(name: string) {
  name =
    name.replace(/[@~./\\:\s]/gi, '') ||
    cryptoRandomString({ length: 10, characters: 'abcdefghijk' });
  return name
    .split('-')
    .map((w, i) => (i > 0 ? titleCase(w) : w))
    .join('');
}

/*
 * Creates a static file with code necessary to load the addons configuration for the server
 *
 */
function getAddonsLoaderCode(addons: string[], addonsInfo: Package[]) {
  // Header
  const parts: string[] = [
    `/*
Don't change this file manually.
It is autogenerated by @plone/registry.
Instead, change the "addons" registration in the app.
*/\n`,
  ];

  // Build a quick lookup for server-enabled addons
  const serverEnabled = new Set(
    (addonsInfo || [])
      .filter((p) => p?.name && p?.hasServerConfig)
      .map((p) => p.name),
  );

  const importStmts: string[] = [];
  const loaderIdents: string[] = [];
  let counter = 0;

  addons.forEach((addonConfigString) => {
    const [pkgName, extraFns] = addonConfigString.split(':') as [
      string,
      string | undefined,
    ];

    // Only include imports/loaders for addons that declare server config
    if (!serverEnabled.has(pkgName)) return;

    const defaultImport = nameFromPackage(pkgName);
    const extras = (extraFns ? extraFns.split(',') : []).map(
      (name) => [name, `${name}${counter++}`] as [string, string],
    );

    const namedImport = extras.length
      ? `, { ${extras.map(([n, alias]) => `${n} as ${alias}`).join(', ')} }`
      : '';
    importStmts.push(
      `import ${defaultImport}${namedImport} from '${pkgName}/config/server';\n`,
    );

    loaderIdents.push(defaultImport, ...extras.map(([, alias]) => alias));
  });

  parts.push(...importStmts);

  // Loader boilerplate
  parts.push(
    `\nconst safeWrapper = (func) => (config) => {\n  const res = func(config);\n  if (typeof res === 'undefined') {\n    throw new Error("Configuration function doesn't return config");\n  }\n  return res;\n};\n\nconst load = (config) => {\n  const addonLoaders = [${loaderIdents.join(', ')}];\n  if (!addonLoaders.every((el) => typeof el === 'function')) {\n    throw new TypeError(\n      'Each addon has to provide a function applying its configuration to the projects configuration.',\n    );\n  }\n  return addonLoaders.reduce((acc, apply) => safeWrapper(apply)(acc), config);\n};\nexport default load;\n`,
  );

  return parts.join('');
}

export function createAddonsServerLoader(
  addons: string[],
  addonsInfo: Package[],
) {
  const addonsLoaderPath = path.join(
    process.cwd(),
    '.plone',
    'registry.loader.server.js',
  );

  const code = getAddonsLoaderCode(addons, addonsInfo);
  fs.writeFileSync(addonsLoaderPath, code);
  return addonsLoaderPath;
}

export { getAddonsLoaderCode, nameFromPackage };
